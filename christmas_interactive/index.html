<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-End 3D Christmas Tree</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000; /* 纯黑背景让光效更突出 */
            font-family: 'Times New Roman', serif;
        }

        #title-container {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            color: #FFD700; /* 更亮的金色 */
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8); /* 增强文字发光 */
            letter-spacing: 5px;
        }

        h1 {
            font-size: 3rem;
            margin: 0;
            font-weight: lighter;
        }

        /* 开始遮罩 */
        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            z-index: 100;
            cursor: pointer;
            transition: opacity 0.8s;
        }

        #start-overlay h2 {
            font-size: 2rem;
            border: 2px solid #FFD700;
            padding: 20px 50px;
            border-radius: 4px;
            background: rgba(255, 215, 0, 0.15);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        /* 图片查看大图遮罩 */
        #photo-modal {
            display: none;
            position: fixed;
            z-index: 200;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            justify-content: center;
            align-items: center;
            cursor: zoom-out;
        }

        #photo-modal img {
            max-width: 90%;
            max-height: 90%;
            border: 5px solid #FFD700;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <div id="title-container">
        <h1>MERRY CHRISTMAS</h1>
    </div>

    <div id="start-overlay">
        <h2>CLICK TO START THE MAGIC</h2>
        <p>Turn up volume & enjoy the lights ✨</p>
    </div>

    <div id="photo-modal">
        <img id="modal-image" src="" alt="Memory">
    </div>

    <audio id="bgm" loop>
        <source src="https://cdn.pixabay.com/download/audio/2022/11/22/audio_febc508520.mp3?filename=christmas-magic-126528.mp3" type="audio/mp3">
    </audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        // 后期处理引入
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- 全局变量 ---
        let scene, camera, renderer, controls, composer;
        let instancedMesh = { spheres: null, cubes: null };
        let topStar;
        let totalCount = 3000; // 增加粒子数量提升密度感
        const dummy = new THREE.Object3D();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        const STATE = { TREE: 0, EXPLODE: 1, TEXT: 2 };
        let currentState = STATE.TREE;
        let isAnimating = false; // 防止快速点击

        let positionsTree = [], positionsExplode = [], positionsText = [];
        let currentPositions = [], currentQuaternions = [], targetPositions = [];
        const colors = [];

        // 相框相关
        let photoFrames = [];
        const photoCount = 8;
        // 示例图片链接（使用 picsum 随机图）
        const photoURLs = Array.from({length: photoCount}, (_, i) => `https://picsum.photos/seed/${i+100}/600/400`);
        let photoTargetPositions = { tree: [], explode: [] };

        // 颜色板：更丰富、高饱和度的颜色
        const colorPalette = [
            new THREE.Color(0xFFD700).convertSRGBToLinear(), // 金
            new THREE.Color(0xFFDF00).convertSRGBToLinear(), // 亮金
            new THREE.Color(0xDC143C).convertSRGBToLinear(), // 猩红
            new THREE.Color(0x006400).convertSRGBToLinear(), // 深绿
            new THREE.Color(0xFFFFFF).convertSRGBToLinear()  // 少量银白色增加闪烁
        ];

        init();

        function init() {
            // 1. 场景设置
            scene = new THREE.Scene();
            // 移除迷雾，让远处的光也能透过来
            // scene.fog = new THREE.FogExp2(0x000000, 0.01);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.set(0, 5, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 限制像素比提升性能
            renderer.shadowMap.enabled = true;
            // 使用 AcesFilmic 色调映射，处理高光溢出
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            // 2. 灯光系统升级
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); // 环境光很弱
            scene.add(ambientLight);

            // 主光源 - 暖金色
            const mainLight = new THREE.DirectionalLight(0xffd700, 3.0);
            mainLight.position.set(15, 30, 20);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            // 补光 - 冷色调，增加金属对比度
            const rimLight = new THREE.DirectionalLight(0xcdd1e4, 2.0);
            rimLight.position.set(-20, 10, -20);
            scene.add(rimLight);

            // 底部向上照的光，照亮树底
            const bottomLight = new THREE.PointLight(0xff4500, 3, 40);
            bottomLight.position.set(0, -10, 0);
            scene.add(bottomLight);

            // 3. 加载环境贴图 (HDR) - 这是金属感的关键
            new RGBELoader()
                .setPath('https://unpkg.com/three@0.160.0/examples/textures/equirectangular/')
                .load('royal_esplanade_1k.hdr', function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    // 不设置背景，只用于环境反射
                    scene.environment = texture; 
                    
                    // 环境加载完成后再加载其他资源
                    loadFontAndCreateAssets();
                });

            // 4. 后期处理 (Bloom)
            setupPostProcessing();

            // 5. 控制器
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.5;
            controls.maxDistance = 120;
            controls.minDistance = 15;

            // 6. 事件与交互
            window.addEventListener('resize', onWindowResize);
            setupInteractions();
        }

        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // 辉光参数调整
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.8,  // strength (强度) - 调高
                0.4,  // radius (半径) - 适中
                0.85  // threshold (阈值) - 只让很亮的地方发光
            );
            composer.addPass(bloomPass);
            
            const outputPass = new OutputPass();
            composer.addPass(outputPass);
        }

        function loadFontAndCreateAssets() {
            const loader = new FontLoader();
            loader.load('https://unpkg.com/three@0.160.0/examples/fonts/optimer_bold.typeface.json', function (font) {
                generateParticleData(font);
                createInstancedMeshes();
                createTopStar();
                createPhotoFrames(); // 创建相框

                targetPositions = positionsTree; // 初始目标
                document.getElementById('start-overlay').style.pointerEvents = 'auto'; // 允许点击开始
                animate();
            });
        }

        function generateParticleData(font) {
             // A. 树形态 (更密集的圆锥体)
             for (let i = 0; i < totalCount; i++) {
                // 使用 sqrt 使得点在底部更密集，向上逐渐稀疏
                const heightRatio = Math.sqrt(Math.random()); 
                const height = heightRatio * 22; // 树高
                const radius = (22 - height) * 0.5 * Math.sqrt(Math.random());
                
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = height - 12; // 居中
                
                positionsTree.push({ x, y, z });
                currentPositions.push(new THREE.Vector3(x, y, z));
                currentQuaternions.push(new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI)));
                
                // 颜色分配：增加金色比例
                let color;
                const rand = Math.random();
                if (rand > 0.6) color = colorPalette[0]; // 金
                else if (rand > 0.4) color = colorPalette[1]; // 亮金
                else if (rand > 0.15) color = colorPalette[2]; // 红
                else if (rand > 0.05) color = colorPalette[3]; // 绿
                else color = colorPalette[4]; // 银白

                colors.push(color.r, color.g, color.b);
            }

            // B. 文字形态 (单行字)
            const textGeo = new TextGeometry('MERRY CHRISTMAS', {
                font: font, size: 3.5, height: 0.8, curveSegments: 6,
                bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.05, bevelSegments: 3
            });
            textGeo.center();
            
            // 采样文字点
            if (textGeo.attributes.position) {
                const array = textGeo.attributes.position.array;
                const ptCount = array.length / 3;
                for (let i = 0; i < totalCount; i++) {
                    const index = (i % ptCount) * 3; 
                    // 添加一些随机抖动，让字看起来是由松散粒子组成的
                    const jitter = 0.3;
                    positionsText.push({
                        x: array[index] + (Math.random()-0.5)*jitter,
                        y: array[index + 1] + (Math.random()-0.5)*jitter,
                        z: array[index + 2] + (Math.random()-0.5)*jitter
                    });
                }
            }

            // C. 爆炸形态 (更大范围的球形扩散)
            for (let i = 0; i < totalCount; i++) {
                const dist = 20 + Math.pow(Math.random(), 2) * 60; // 扩散得更远
                const theta = THREE.MathUtils.randFloatSpread(360); 
                const phi = THREE.MathUtils.randFloatSpread(360); 
                positionsExplode.push({
                    x: dist * Math.sin(theta) * Math.cos(phi),
                    y: dist * Math.sin(theta) * Math.sin(phi) * 0.7, // 压扁一点y轴
                    z: dist * Math.cos(theta)
                });
            }
        }

        function createInstancedMeshes() {
            // 材质升级：更高光泽度的 PBR 金属
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.08, // 极度光滑
                metalness: 1.0,  // 纯金属
                envMapIntensity: 1.5 // 增强环境反射强度
            });

            // 稍微调整几何体大小
            const sphereGeo = new THREE.SphereGeometry(0.2, 16, 16);
            const cubeGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            // 增加一点发光的八面体作为点缀
            const octaGeo = new THREE.OctahedronGeometry(0.25, 0);

            const sphereCount = Math.floor(totalCount * 0.5);
            const cubeCount = Math.floor(totalCount * 0.4);
            const octaCount = totalCount - sphereCount - cubeCount;

            instancedMesh.spheres = new THREE.InstancedMesh(sphereGeo, material, sphereCount);
            instancedMesh.cubes = new THREE.InstancedMesh(cubeGeo, material, cubeCount);
            instancedMesh.octas = new THREE.InstancedMesh(octaGeo, material, octaCount);

            let sIdx=0, cIdx=0, oIdx=0;
            for (let i = 0; i < totalCount; i++) {
                dummy.position.set(positionsTree[i].x, positionsTree[i].y, positionsTree[i].z);
                dummy.updateMatrix();
                const color = new THREE.Color(colors[i*3], colors[i*3+1], colors[i*3+2]);

                if (i < sphereCount) {
                    instancedMesh.spheres.setMatrixAt(sIdx, dummy.matrix);
                    instancedMesh.spheres.setColorAt(sIdx++, color);
                } else if (i < sphereCount + cubeCount) {
                    instancedMesh.cubes.setMatrixAt(cIdx, dummy.matrix);
                    instancedMesh.cubes.setColorAt(cIdx++, color);
                } else {
                    instancedMesh.octas.setMatrixAt(oIdx, dummy.matrix);
                    instancedMesh.octas.setColorAt(oIdx++, color);
                    // 让八面体自发光
                     if(Math.random() > 0.5) instancedMesh.octas.setColorAt(oIdx-1, new THREE.Color(2,2,0));
                }
            }
            scene.add(instancedMesh.spheres, instancedMesh.cubes, instancedMesh.octas);
        }

        function createTopStar() {
            // 使用两个几何体叠加，增加层次感
            const starGroup = new THREE.Group();
            const geoBig = new THREE.OctahedronGeometry(1.8, 0);
            const geoSmall = new THREE.OctahedronGeometry(1.0, 0);
            
            // 极度发光的材质，用于触发 Bloom
            const matEmissive = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                emissive: 0xFFD700,
                emissiveIntensity: 3.0, // 强度调高
                metalness: 1, roughness: 0
            });

            const meshBig = new THREE.Mesh(geoBig, matEmissive);
            const meshSmall = new THREE.Mesh(geoSmall, matEmissive);
            meshSmall.rotation.y = Math.PI / 4; // 错开角度

            starGroup.add(meshBig, meshSmall);
            starGroup.position.set(0, 12, 0);
            
            // 星星内部的点光源
            const light = new THREE.PointLight(0xFFD700, 2.5, 30);
            starGroup.add(light);
            
            topStar = starGroup;
            scene.add(topStar);
        }

        function createPhotoFrames() {
            const loader = new THREE.TextureLoader();
            const frameGeo = new THREE.PlaneGeometry(4, 3);

            for(let i = 0; i < photoCount; i++) {
                const tex = loader.load(photoURLs[i]);
                tex.colorSpace = THREE.SRGBColorSpace;
                // 材质：带金色边框感的发光照片
                const mat = new THREE.MeshStandardMaterial({
                    map: tex,
                    roughness: 0.2, metalness: 0.8,
                    emissive: 0xffffff, emissiveMap: tex, emissiveIntensity: 0.2,
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(frameGeo, mat);
                // 存储完整图片链接用于点击展示
                mesh.userData.fullImage = photoURLs[i]; 

                // 初始位置：藏在树中心
                mesh.position.set(0, -2, 0);
                mesh.scale.set(0,0,0); // 初始不可见
                photoFrames.push(mesh);
                scene.add(mesh);

                // 计算爆炸目标位置 (围绕中心散开)
                const angle = (i / photoCount) * Math.PI * 2;
                const radius = 25 + Math.random() * 10;
                photoTargetPositions.explode.push(new THREE.Vector3(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * 20,
                    Math.sin(angle) * radius
                ));
                 // 树目标位置 (隐藏)
                 photoTargetPositions.tree.push(new THREE.Vector3(0,-5,0));
            }
        }

        function setupInteractions() {
            const overlay = document.getElementById('start-overlay');
            const bgm = document.getElementById('bgm');
            const modal = document.getElementById('photo-modal');
            const modalImg = document.getElementById('modal-image');

            overlay.addEventListener('click', () => {
                overlay.style.opacity = 0;
                setTimeout(() => overlay.style.display = 'none', 800);
                bgm.volume = 0.6;
                bgm.play().catch(e => console.log("BGM autoplay blocked"));
                // 绑定主场景交互
                document.addEventListener('click', onSceneClick, false);
                document.addEventListener('mousemove', onMouseMove, false);
            });

            modal.addEventListener('click', () => {
                modal.style.display = 'none';
            });

            function onMouseMove(event) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }

            function onSceneClick(event) {
                // 优先处理爆炸状态下的相框点击
                if (currentState === STATE.EXPLODE) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(photoFrames);
                    if (intersects.length > 0) {
                        const targetPhoto = intersects[0].object;
                        modalImg.src = targetPhoto.userData.fullImage;
                        modal.style.display = 'flex';
                        return; // 如果点击了照片，不触发状态切换
                    }
                }

                // 状态切换逻辑
                if (isAnimating) return;
                isAnimating = true;
                setTimeout(() => isAnimating = false, 1500);

                if (currentState === STATE.TREE) {
                    // Tree -> Explode
                    currentState = STATE.EXPLODE;
                    targetPositions = positionsExplode;
                    if(topStar) gsap.to(topStar.scale, {x:0,y:0,z:0, duration: 0.5});
                    controls.autoRotateSpeed = 0.2;
                    // 照片飞出
                    photoFrames.forEach((mesh, i) => {
                        gsap.to(mesh.scale, {x:1,y:1,z:1, duration: 1, delay: Math.random()*0.5});
                    });

                } else if (currentState === STATE.EXPLODE) {
                    // Explode -> Text
                    currentState = STATE.TEXT;
                    targetPositions = positionsText;
                    controls.autoRotateSpeed = 0;
                    gsap.to(camera.position, {x:0,y:0,z:50, duration: 2}); // 相机回正查看文字
                    // 照片隐藏
                    photoFrames.forEach(mesh => gsap.to(mesh.scale, {x:0,y:0,z:0, duration: 0.8}));

                } else {
                    // Text -> Tree
                    currentState = STATE.TREE;
                    targetPositions = positionsTree;
                    if(topStar) setTimeout(() => gsap.to(topStar.scale, {x:1,y:1,z:1, duration: 1}), 1000);
                    controls.autoRotateSpeed = 1.5;
                    gsap.to(camera.position, {x:0,y:5,z:45, duration: 2}); // 相机复位
                }
            }
        }
        
        // 使用 GSAP 库来进行更平滑的动画过渡（需要引入）
        import { gsap } from 'https://cdn.skypack.dev/gsap';

        function animate() {
            requestAnimationFrame(animate);

            const lerpSpeed = 0.04; 
            let sIdx=0, cIdx=0, oIdx=0;
            const sphereCount = instancedMesh.spheres.count;
            const cubeCount = instancedMesh.cubes.count;

            // 粒子动画
            for (let i = 0; i < totalCount; i++) {
                const current = currentPositions[i];
                const target = targetPositions[i];
                const quat = currentQuaternions[i];

                current.lerp(target, lerpSpeed);
                // 增加随机自转
                quat.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), 0.02 * (Math.random()-0.5)));
                
                dummy.position.copy(current);
                dummy.rotation.setFromQuaternion(quat);
                // 爆炸状态下让物体稍微变大一点
                const scale = (currentState === STATE.EXPLODE) ? 1.2 : 1.0;
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();

                if (i < sphereCount) instancedMesh.spheres.setMatrixAt(sIdx++, dummy.matrix);
                else if (i < sphereCount + cubeCount) instancedMesh.cubes.setMatrixAt(cIdx++, dummy.matrix);
                else instancedMesh.octas.setMatrixAt(oIdx++, dummy.matrix);
            }
            instancedMesh.spheres.instanceMatrix.needsUpdate = true;
            instancedMesh.cubes.instanceMatrix.needsUpdate = true;
            instancedMesh.octas.instanceMatrix.needsUpdate = true;

            // 相框动画
            if (photoFrames.length > 0) {
                const photoTargets = (currentState === STATE.EXPLODE) ? photoTargetPositions.explode : photoTargetPositions.tree;
                photoFrames.forEach((frame, i) => {
                    if (currentState === STATE.EXPLODE) {
                         frame.position.lerp(photoTargets[i], lerpSpeed * 0.8);
                         // 让相框始终面向相机
                         frame.lookAt(camera.position);
                    } else {
                         // 非爆炸状态迅速归位隐藏
                         frame.position.lerp(photoTargets[i], 0.1);
                    }
                });
            }

            if (topStar && topStar.visible) {
                topStar.rotation.y += 0.015;
                // 星星呼吸灯效果
                topStar.children.forEach(mesh => {
                    if(mesh.material.emissiveIntensity) {
                         mesh.material.emissiveIntensity = 2.5 + Math.sin(Date.now() * 0.002) * 1.0;
                    }
                });
            }

            controls.update();
            // 使用 composer 替代 renderer 进行渲染，以显示辉光效果
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
